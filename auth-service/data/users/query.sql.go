// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package users

import (
	"context"
	"time"
)

const Delete = `-- name: Delete :exec
delete
from users
where id = $1
`

func (q *Queries) Delete(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteStmt, Delete, id)
	return err
}

const GetAll = `-- name: GetAll :many
select id,
       email,
       first_name,
       last_name,
       password,
       user_active,
       created_at,
       updated_at
from users
order by last_name
`

func (q *Queries) GetAll(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.getAllStmt, GetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Password,
			&i.UserActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetByEmail = `-- name: GetByEmail :one
select id,
       email,
       first_name,
       last_name,
       password,
       user_active,
       created_at,
       updated_at
from users
where email = $1
`

func (q *Queries) GetByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getByEmailStmt, GetByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.UserActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetOne = `-- name: GetOne :one
select id,
       email,
       first_name,
       last_name,
       password,
       user_active,
       created_at,
       updated_at
from users
where id = $1
`

func (q *Queries) GetOne(ctx context.Context, id int32) (User, error) {
	row := q.queryRow(ctx, q.getOneStmt, GetOne, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.UserActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const Insert = `-- name: Insert :one
insert into users (email, first_name, last_name, password, user_active, created_at, updated_at)
values ($1, $2, $3, $4, $5, $6, $7)
returning id
`

type InsertParams struct {
	Email      string    `db:"email" json:"email"`
	FirstName  string    `db:"first_name" json:"firstName"`
	LastName   string    `db:"last_name" json:"lastName"`
	Password   string    `db:"password" json:"password"`
	UserActive int32     `db:"user_active" json:"userActive"`
	CreatedAt  time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt  time.Time `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) Insert(ctx context.Context, arg InsertParams) (int32, error) {
	row := q.queryRow(ctx, q.insertStmt, Insert,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.UserActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const ResetPassword = `-- name: ResetPassword :exec
update users
set password = $1
where id = $2
`

type ResetPasswordParams struct {
	Password string `db:"password" json:"password"`
	ID       int32  `db:"id" json:"id"`
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) error {
	_, err := q.exec(ctx, q.resetPasswordStmt, ResetPassword, arg.Password, arg.ID)
	return err
}

const Update = `-- name: Update :exec
update users
set email       = $1,
    first_name  = $2,
    last_name   = $3,
    user_active = $4,
    updated_at  = $5
where id = $6
`

type UpdateParams struct {
	Email      string    `db:"email" json:"email"`
	FirstName  string    `db:"first_name" json:"firstName"`
	LastName   string    `db:"last_name" json:"lastName"`
	UserActive int32     `db:"user_active" json:"userActive"`
	UpdatedAt  time.Time `db:"updated_at" json:"updatedAt"`
	ID         int32     `db:"id" json:"id"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) error {
	_, err := q.exec(ctx, q.updateStmt, Update,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.UserActive,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
